/**
 * Event Manager Service
 * TIBCO Cloud(TM) Live Apps maintains an audit trail that records various business events that occur during the lifecycle of a Case - for example, when the Case was started and by whom, or when the Case state or data changed and what that change was.   An __AuditEvent__ is a map of attributes (name/value pairs), which provide the audit details about a specific business event. Each AuditEvent includes the following attributes:  * __key__: Unique key value that identifies this AuditEvent within the audit trail * __id__: The unique identifier of the AuditEvent * __type__: The type of the AuditEvent * __creationTime__: Date and time on which this AuditEvent was created * __message__: Description of the AuditEvent * __messageId__: The identifier for the type of AuditEvent that occurred * __severity__: Severity level of the AuditEvent - for example, AUDIT, WARN or ERROR * __subscriptionId__: The unique identifier of the subscription to which the AuditEvent belongs * _other context-specific attributes_: Provides information relevant to the particular AuditEvent - for example, caseId, processId or userId     The TIBCO(R) Live Apps Event Manager Service allows you to retrieve AuditEvents for a specific Case. An audit trail is represented by a series of AuditEvents.  __Note__: An AuditEvent is only stored for a specific period of time (the AuditRetentionPeriod), which is defined for the subscription. An AuditEvent is removed when this period has expired.    
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: liveapps@tibco.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { AttributeValue } from '../model/attributeValue';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://localhost/event/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum AuditEventsApiApiKeys {
}

export class AuditEventsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: AuditEventsApiApiKeys, value: string) {
        (this.authentications as any)[AuditEventsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * __Note__: This method uses the $top and $startat parameters to control paging of the returned data. (Other Live Apps services use $top and $skip instead.) 
     * @summary Returns a list of AuditEvents for a Case that match the specified $filter, $select and $sandbox parameters.
     * @param $filter A filter expression that defines the audit data to be returned. The expression can contain the following operands:   * __type__ (required): The type of data to be returned. The value must be one of the following:    * __\&#39;case\&#39;__: All AuditEvents for a specific Case   * __\&#39;casestate\&#39;__: Only AuditEvents generated when a state change occurred, for a specific Case    * __\&#39;casedata\&#39;__: A single AuditEvent that contains the Case data associated with another AuditEvent (for a specific Case)    Supported operators: \&#39;eq\&#39;.    * __id__ (required): The identifier of the specific Case or AuditEvent for which data should be returned. The value must be either:    * _caseReference_ (if _type_ is __case__ or __casestate__): The case reference of the required Case.      * _uuid_ (if _type_ is __casedata__): The uuid value of a specific AuditEvent for a specific Case, obtained from an earlier GET /auditEvents request.    Supported operators: \&#39;eq\&#39;.    * __creationTime__ (optional): The specification of a date/time range in which AuditEvents to be returned were created. The value must be specified using the format:    *yyyy*-*mm*-*dd*THH:*MM*:*SS*.*sss*Z         and must include a timezone. (See the _Filtering and Sorting_ Key Concepts page for more information about how to specify date/times in $filter queries.)    Supported operators: \&#39;gt\&#39;, \&#39;lt\&#39;, \&#39;ge\&#39; and \&#39;le\&#39;. Only one upper and one lower boundary can be specified.    For example, the following string returns all AuditEvents for the Case with caseReference 5141, that were created on or after 07-Sep-2017 in the UTC-08:00 time-zone:  &#x60;$filter&#x3D;type eq \&#39;case\&#39; and id eq \&#39;5141\&#39; and creationTime gt 2017-09-07T-08:00&#x60; 
     * @param $top The maximum number of AuditEvents to return. (If $top is omitted, the value defaults to 100.)
     * @param $startat The \&#39;key\&#39; value of the last AuditEvent returned on the previous page of data. The returned data starts from the next AuditEvent after the one whose \&#39;key\&#39; is specified. If $startat is omitted, the first page of data is supplied.
     * @param $select A comma-separated list of attributes to be returned for each AuditEvent. Note that: * Unrecognised attribute names in the $select are silently ignored. * If $select is not specified, all attributes are returned.  
     * @param $sandbox The id of the Sandbox with which the requested audit data is associated.  __Note__: This parameter must be supplied when requesting audit data for __case__, __casestate__ or __casedata__. 
     * @param $orderby The order in which returned AuditEvents should be sorted: \&quot;creationTime\&quot; (defaults to asc),\&quot;creationTime asc\&quot; or \&quot;creationTime desc\&quot;. If $orderby is omitted, results are sorted by \&quot;creationTime asc\&quot;. 
     */
    public async getAudit ($filter: string, $top?: string, $startat?: string, $select?: string, $sandbox?: string, $orderby?: 'creationTime' | 'creationTime asc' | 'creationTime desc', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<{ [key: string]: AttributeValue; }>;  }> {
        const localVarPath = this.basePath + '/auditEvents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter '$filter' is not null or undefined
        if ($filter === null || $filter === undefined) {
            throw new Error('Required parameter $filter was null or undefined when calling getAudit.');
        }

        if ($filter !== undefined) {
            localVarQueryParameters['$filter'] = ObjectSerializer.serialize($filter, "string");
        }

        if ($top !== undefined) {
            localVarQueryParameters['$top'] = ObjectSerializer.serialize($top, "string");
        }

        if ($startat !== undefined) {
            localVarQueryParameters['$startat'] = ObjectSerializer.serialize($startat, "string");
        }

        if ($select !== undefined) {
            localVarQueryParameters['$select'] = ObjectSerializer.serialize($select, "string");
        }

        if ($sandbox !== undefined) {
            localVarQueryParameters['$sandbox'] = ObjectSerializer.serialize($sandbox, "string");
        }

        if ($orderby !== undefined) {
            localVarQueryParameters['$orderby'] = ObjectSerializer.serialize($orderby, "'creationTime' | 'creationTime asc' | 'creationTime desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<{ [key: string]: AttributeValue; }>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<{ [key: string]: AttributeValue; }>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
