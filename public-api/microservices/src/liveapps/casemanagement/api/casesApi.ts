/**
 * Case Manager Service
 * The TIBCO Cloud(TM) Live Apps Case Manager Service manages the following resources:  * __Types__: A Type contains the essential data definition of a TIBCO(R) Live Apps application - that is, the data fields, data types and states which are created by an application designer when they create an application in Live Apps Designer. There are two sorts of Type:    * __Case__: A Case Type contains the definition of:       * the top-level data fields used by the application. These data fields (referred to hereafter as \'attributes\' of the Case) can be either simple types (such as strings or dates), or custom data types (that group together sets of existing data fields to suit the application\'s purpose).        * the states used by the application.       * details of Case Creator and Case Action processes defined in the application.               * __Structured__: A Structured Type contains the definition of a custom data type used by the application, which also has fields (\'attributes\').  * __Cases__: A Case is a particular instance of a Case Type. Users use Live Apps Case Manager to start Cases and run them through to completion. A Case contains the particular values of the data fields and states for that Case as it progresses from creation to completion.  __Paginating Results Lists__  By default, the GET /cases and GET /types methods do not return their entire results list. Instead, they return 10 items from the results list, starting from the beginning of the list. You can override this default behaviour by using the following parameters:  * $top - to specify how many items are returned from the results list. ($top must be a value from 1 to 1000.) * $skip - to specify the starting position in the results list from which to return items.  
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: liveapps@tibco.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { DeleteCasesResponse } from '../model/deleteCasesResponse';
import { GetCaseResponseItem } from '../model/getCaseResponseItem';
import { PutCasesRequest } from '../model/putCasesRequest';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://localhost/case/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum CasesApiApiKeys {
}

export class CasesApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: CasesApiApiKeys, value: string) {
        (this.authentications as any)[CasesApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Purgeable Cases - meaning those that are in a terminal (or end) state - can be deleted to prevent them from, over time, building up and consuming excessive storage space in the current Subscription. However, __use caution when deleting Cases__, as doing so permanently deletes the Case, and the deletion cannot be undone. <br> You can use the GET /types method to determine which states are purgeable for a particular Case Type. Terminal states have the \'isTerminal\' attribute set to \'true\'. <br> Note: Cases are not deleted immediately when this method is executed. Instead, each Case\'s \'metadata.markedForPurge\' attribute is set and the Case is deleted asynchronously later. 
     * @summary Deletes all purgeable Cases that match the specified query parameters.
     * @param $sandbox The id of the Sandbox from which to delete purgeable Cases. (You can obtain Sandbox Ids using the Authorization Engine Service.) 
     * @param $filter A filter expression that defines the Cases to be deleted. The expression can contain the following operands:  * __applicationId__ (required): The identifier of the specific application for which Cases should be deleted.    Supported operators: \&#39;eq\&#39;    * __typeId__ (required): The identifier of the specific Case Type for which Cases should be deleted.    Supported operators: \&#39;eq\&#39;  * __purgeable__ (required): Must be set to (TRUE).     Supported operators: \&#39;eq\&#39;  * __modificationTimestamp__ (optional): The specification of a date/time range in which the Cases to be deleted were last modified.    Supported operators: \&#39;lt\&#39;, \&#39;le\&#39;  * __stateId__ (optional): The identifier of the specific terminal state for which Cases should be deleted. If \&#39;stateId\&#39; is omitted, Cases in any terminal state are deleted.    Supported operators: \&#39;eq\&#39;               For example:   &#x60;$filter&#x3D;applicationId eq 8 and typeId eq 1 and  purgeable eq TRUE and stateId eq 9&#x60;  See the _Filtering and Sorting_ Key Concepts page for more information about how to construct valid filter expressions. 
     */
    public async deleteCases ($sandbox: string, $filter: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeleteCasesResponse;  }> {
        const localVarPath = this.basePath + '/cases';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter '$sandbox' is not null or undefined
        if ($sandbox === null || $sandbox === undefined) {
            throw new Error('Required parameter $sandbox was null or undefined when calling deleteCases.');
        }

        // verify required parameter '$filter' is not null or undefined
        if ($filter === null || $filter === undefined) {
            throw new Error('Required parameter $filter was null or undefined when calling deleteCases.');
        }

        if ($sandbox !== undefined) {
            localVarQueryParameters['$sandbox'] = ObjectSerializer.serialize($sandbox, "string");
        }

        if ($filter !== undefined) {
            localVarQueryParameters['$filter'] = ObjectSerializer.serialize($filter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeleteCasesResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DeleteCasesResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Returns the set of information about a particular Case that matches the specified query parameters.
     * @param caseReference The Case reference of the Case.
     * @param $sandbox The ID of the Sandbox that contains the Case.
     * @param $select A comma-separated list of identifiers defining the attributes to be returned for the Case. If $select is not specified, all attributes are returned.    * __casedata__ (or __c__): Returns the current value of all Case attributes. This format contains the system identifiers (_id and _value properties), so is not compliant with the JSON schema returned by the GET /types method in the jsonSchema object.    * __untaggedCasedata__ (or __uc__): Returns the the current value of all Case attributes with system identifiers (_id and _value properties) removed. This format is compliant with the JSON schema returned by the GET /types method (in the jsonSchema object).                    * __summary__ (or __s__): Returns the Case summary attributes and their current values.      * __metadata__ (or __m__): Returns the following metadata attributes for the Case. Individual attributes can be specified by suffixing \&#39;metadata\&#39; with a dot followed by the identifier.        * __createdBy__ (or __cb__)     * __creationTimestamp__ (or __ct__)      * __modifiedBy__ (or __mb__)     * __modificationTimestamp__ (or __mt__)     * __lock__ (or __l__)     * __lockType__ (or __lt__)     * __lockedBy__ (or __lb__)     * __msLockExpiry__ (or __msle__)     * __msSystemTime__ (or __msst__)     * __markedForPurge__ (or __mfp__)     * __applicationId__ (or __ai__)      * __typeId__ (or __ti__)    For example, the following string returns the Case summary, modificationTimestamp and modifiedBy attributes:    &#x60;$select&#x3D;s,m.mt,m.mb&#x60;           
     * @param $user Test userId for Development sandbox only. Claims must still contain a valid userid but will be overridden when the optional $user parameter is specified    
     */
    public async getCase (caseReference: string, $sandbox: string, $select?: string, $user?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<GetCaseResponseItem>;  }> {
        const localVarPath = this.basePath + '/cases/{caseReference}'
            .replace('{' + 'caseReference' + '}', encodeURIComponent(String(caseReference)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'caseReference' is not null or undefined
        if (caseReference === null || caseReference === undefined) {
            throw new Error('Required parameter caseReference was null or undefined when calling getCase.');
        }

        // verify required parameter '$sandbox' is not null or undefined
        if ($sandbox === null || $sandbox === undefined) {
            throw new Error('Required parameter $sandbox was null or undefined when calling getCase.');
        }

        if ($sandbox !== undefined) {
            localVarQueryParameters['$sandbox'] = ObjectSerializer.serialize($sandbox, "string");
        }

        if ($select !== undefined) {
            localVarQueryParameters['$select'] = ObjectSerializer.serialize($select, "string");
        }

        if ($user !== undefined) {
            localVarQueryParameters['$user'] = ObjectSerializer.serialize($user, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<GetCaseResponseItem>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<GetCaseResponseItem>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieves Cases by specifying a list of Case references or a set of criteria that Cases must match.  By default, only 10 items from the results list are returned, starting from the beginning of the list. You can override this default behaviour by using the $top and $skip parameters.           
     * @summary Returns Cases that match the specified query parameters.
     * @param $sandbox The id of the Sandbox from which to return Cases. (You can obtain Sandbox Ids using the Authorization Engine Service.)   Note: This parameter is required unless $count is specified.  
     * @param $filter A filter expression that defines the Cases to be returned. The expression can contain the following operands:  * __applicationId__ (required if $count is not used): The identifier of the specific application for which Cases should be returned.    Supported operators: \&#39;eq\&#39;    * __typeId__ (required if $count is not used): The identifier of the specific Case Type for which Cases should be returned.    Supported operators: \&#39;eq\&#39;  * __purgeable__ (optional): Boolean value specifying whether to return Cases that would (TRUE) or would not (FALSE) be affected by a purge request.    Supported operators: \&#39;eq\&#39;  * __modificationTimestamp__ (optional): The specification of a date/time range in which the Cases to be returned were last modified.    Supported operators: \&#39;lt\&#39;, \&#39;le\&#39;  * __stateId__ (optional): The identifier of the specific state for which Cases should be returned.    Supported operators: \&#39;eq\&#39;  * __lock__ (optional): Boolean value specifying whether to return Cases that are locked (TRUE) or locked (FALSE).    Supported operators: \&#39;eq\&#39;  * __caseReference__ (optional): A comma-separated list of Case references for which Cases should be returned. (Any Case reference that no longer exists,  because the Case has been deleted, is simply ignored.)    Supported functions: \&#39;in\&#39;  For example:   &#x60;$filter&#x3D;applicationId eq 8 and typeId eq 1 and stateId eq 9&#x60;  See the _Filtering and Sorting_ Key Concepts page for more information about how to construct valid filter expressions. 
     * @param $select A comma-separated list of identifiers defining the properties to be returned for each Case. If $select is not specified, all properties are returned.    * __caseReference__ (or __cr__): Returns the Case reference.      * __casedata__ (or __c__): Returns the current value of all Case attributes. This format contains the system identifiers (_id and _value properties), so is not compliant with the JSON schema returned by the GET /types method in the jsonSchema object.    * __untaggedCasedata__ (or __uc__): Returns the the current value of all Case attributes with system identifiers (_id and _value properties) removed. This format is compliant with the JSON schema returned by the GET /types method (in the jsonSchema object).                      * __summary__ (or __s__): Returns the current values of those Case attributes marked as summary attributes.      * __metadata__ (or __m__): Returns the following metadata for the Case. Individual metadata properties can be specified by suffixing \&#39;metadata\&#39; with a dot followed by the identifier.        * __createdBy__ (or __cb__)     * __creationTimestamp__ (or __ct__)      * __modifiedBy__ (or __mb__)     * __modificationTimestamp__ (or __mt__)     * __lock__ (or __l__)     * __lockType__ (or __lt__)     * __lockedBy__ (or __lb__)     * __msLockExpiry__ (or __msle__)     * __msSystemTime__ (or __msst__)     * __markedForPurge__ (or __mfp__)     * __applicationId__ (or __ai__)      * __typeId__ (or __ti__)        Note: \&#39;metadata\&#39; cannot be used if $search is used.  For example:  * The following string returns the Case reference and summary attributes:     &#x60;$select&#x3D;caseReference,summary&#x60;    * The following string returns the Case summary, modificationTimestamp and modifiedBy attributes:    &#x60;$select&#x3D;s,m.mt,m.mb&#x60; 
     * @param $skip The number of items to exclude from the results list, counting from the beginning of the list. The value must be 0 or greater. For example, &#x60;$skip&#x3D;80&#x60; results in the first 80 items in the results list being ignored. Subsequent items are returned, starting with the 81st item in the list.    Note: If $search is used, the sum of $skip and $top must be less than or equal to 10000. An error will occur if this limit is exceeded. 
     * @param $top The maximum number of items to be returned from the results list (with the first item determined by the value of the $skip parameter). The value of $top must be between 1 and 1000. For example, &#x60;$top&#x3D;20&#x60; returns 20 items from the results list, or all the results if the list contains 19 or fewer items.  If $top is not specified, a default value of 10 is used (unless $count&#x3D;true is also specified, in which case the default value of 10 is ignored).         
     * @param $search Limits results to just those that match the given search string.  Only attributes that are defined as \&#39;Searchable\&#39; in Live Apps Designer are searched.  Note: If $search is used:   * $sandbox must be set to the value of the Production Sandbox. $search cannot be used on a Developer Sandbox.   * $select&#x3D;metadata cannot be used.   * $top is required. 
     * @param $count If set to \&#39;TRUE\&#39;, returns the number of Cases in the result, rather than the Cases themselves.    Note: $count cannot be used if $top is used. If $count&#x3D;true is specified, the default $top value (10) is ignored. 
     * @param $user Test userId for Development sandbox only. Claims must still contain a valid userid but will be overridden when the optional $user parameter is specified    
     */
    public async getCases ($sandbox?: string, $filter?: string, $select?: string, $skip?: string, $top?: string, $search?: string, $count?: boolean, $user?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<GetCaseResponseItem>;  }> {
        const localVarPath = this.basePath + '/cases';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if ($sandbox !== undefined) {
            localVarQueryParameters['$sandbox'] = ObjectSerializer.serialize($sandbox, "string");
        }

        if ($filter !== undefined) {
            localVarQueryParameters['$filter'] = ObjectSerializer.serialize($filter, "string");
        }

        if ($select !== undefined) {
            localVarQueryParameters['$select'] = ObjectSerializer.serialize($select, "string");
        }

        if ($skip !== undefined) {
            localVarQueryParameters['$skip'] = ObjectSerializer.serialize($skip, "string");
        }

        if ($top !== undefined) {
            localVarQueryParameters['$top'] = ObjectSerializer.serialize($top, "string");
        }

        if ($search !== undefined) {
            localVarQueryParameters['$search'] = ObjectSerializer.serialize($search, "string");
        }

        if ($count !== undefined) {
            localVarQueryParameters['$count'] = ObjectSerializer.serialize($count, "boolean");
        }

        if ($user !== undefined) {
            localVarQueryParameters['$user'] = ObjectSerializer.serialize($user, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<GetCaseResponseItem>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<GetCaseResponseItem>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Unlocking a Case changes the value of the Case\'s \'metadata.lock\' attribute. This method cannot be used to change the Case\'s content, state, or any other metadata. 
     * @summary Unlocks a particular Case.
     * @param caseReference The Case reference of the Case.
     * @param $sandbox The id of the Sandbox that contains the Case.
     * @param $select The attribute to be returned (after a successul PUT operation). This must be \&#39;metadata\&#39; - that is:  &#x60;$select&#x3D;metadata&#x60; 
     * @param payload Unlocks a Case. Use the following:  * _{\&quot;metadata\&quot;:{\&quot;lock\&quot;:false}}_: to unlock a Case  As the metadata\&#39;s lock property is the only thing that can be updated, anything else in the request body will be ignored. 
     */
    public async updateCase (caseReference: string, $sandbox: string, $select: string, payload: PutCasesRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetCaseResponseItem;  }> {
        const localVarPath = this.basePath + '/cases/{caseReference}'
            .replace('{' + 'caseReference' + '}', encodeURIComponent(String(caseReference)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'caseReference' is not null or undefined
        if (caseReference === null || caseReference === undefined) {
            throw new Error('Required parameter caseReference was null or undefined when calling updateCase.');
        }

        // verify required parameter '$sandbox' is not null or undefined
        if ($sandbox === null || $sandbox === undefined) {
            throw new Error('Required parameter $sandbox was null or undefined when calling updateCase.');
        }

        // verify required parameter '$select' is not null or undefined
        if ($select === null || $select === undefined) {
            throw new Error('Required parameter $select was null or undefined when calling updateCase.');
        }

        // verify required parameter 'payload' is not null or undefined
        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling updateCase.');
        }

        if ($sandbox !== undefined) {
            localVarQueryParameters['$sandbox'] = ObjectSerializer.serialize($sandbox, "string");
        }

        if ($select !== undefined) {
            localVarQueryParameters['$select'] = ObjectSerializer.serialize($select, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(payload, "PutCasesRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetCaseResponseItem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetCaseResponseItem");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
