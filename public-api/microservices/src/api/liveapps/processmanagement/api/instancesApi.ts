/**
 * Business Process Management Service
 * The TIBCO(R) Live Apps Business Process Management Service manages the following resources:  * __Case Creator processes__: A Case Creator process is a process definition containing the business logic used to create a Case - this may simply be a single step process that provides a form for a user to complete, or a more involved sequence of steps. An application designer creates at least one Case Creator process when they create an application in Live Apps Designer. A user creates a Process Instance when they use Live Apps Case Manager to start a Case.     * __Case Action processes__: A Case Action process is a process definition containing the business logic used to execute some sort of unscheduled action on an active Case. An application designer creates as many Case Action processes as they need when they create an application in Live Apps Designer. A user creates a Process Instance when they use Live Apps Case Manager to execute an Action on an existing Case.    * __Process Instances__: A Process Instance is a particular instance of a Case Creator process or a Case Action process.   * Process Instance __States__: A Process Instance is, at any time, in one of the following States: STARTED, ACTIVE, COMPLETED, DELAYED, CANCELLED, HALTED or UNKNOWN. Process Instance States are system-defined values representing logical stages in the lifecycle of a process and are used by every Process Instance.     Note: Process Instance States should not be confused with Case states, which are application-defined values representing logical stages in the lifecycle of a Case. An application designer creates whatever Case states they need when they create an application in Live Apps Designer. They can configure the application to only allow users to execute a particular Case Action (that is, start a Process Instance of a Case Action process) when a Case is in a particular (Case) state. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: liveapps@tibco.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Instance } from '../model/instance';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = '/process/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum InstancesApiApiKeys {
}

export class InstancesApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: InstancesApiApiKeys, value: string) {
        (this.authentications as any)[InstancesApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * 
     * @summary Returns summary information about a specified Process Instance.
     * @param id The unique identifier of the Process Instance.
     */
    public async getInstance (id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Instance;  }> {
        const localVarPath = this.basePath + '/instances/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getInstance.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Instance;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Instance");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Information is returned only for Process Instances to which the current User has access.
     * @summary Returns summary information about Process Instances that match the specified query parameters.
     * @param $sandbox The id of the Sandbox from which to return data. (You can obtain Sandbox Ids using the GET /sandboxes method in the Authorization Engine Service.)
     * @param $filter A filter expression that defines the Process Instances to be returned. The expression can contain the following operands:  * __caseReference__ (required if \&#39;state\&#39; is not used): The reference of the specific Case for which Process Instances should be returned.  * __state__ (required if \&#39;caseReference\&#39; is not used): The identifier of the specific State for which Process Instances should be returned. This must be one of the following strings: \&#39;STARTING\&#39;, \&#39;ACTIVE\&#39;, \&#39;COMPLETED\&#39;, \&#39;CANCELLED, \&#39;DELAYED\&#39; or \&#39;HALTED\&#39;.  Supported operators: \&#39;eq\&#39;  Note: Either \&#39;caseReference\&#39; or \&#39;state\&#39; must be specified, or both can be specified by using the \&#39;AND\&#39; operator.  For example, the following string returns all Process Instances for caseReference \&#39;35\&#39; that are currently \&#39;ACTIVE\&#39;:     $filter&#x3D;caseReference eq 35 and state eq \&#39;ACTIVE\&#39; 
     * @param $skip The number of items to exclude from the results list, counting from the beginning of the list. The value must be 0 or greater. For example, &#x60;$skip&#x3D;80&#x60; results in the first 80 items in the results list being ignored. Subsequent items are returned, starting with the 81st item in the list.   Note: \&#39;$top\&#39; must also be used if \&#39;$skip\&#39; is used. 
     * @param $top The maximum number of items to be returned from the results list (with the first item determined by the value of the $skip parameter). The value of $top must be 1 or greater. For example, &#x60;$top&#x3D;20&#x60; returns 20 items from the results list, or all the results if the list contains 20 or fewer items.  Note: \&#39;$skip\&#39; must also be used if \&#39;$top\&#39; is used. 
     */
    public async listInstances ($sandbox: string, $filter?: string, $skip?: number, $top?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Instance>;  }> {
        const localVarPath = this.basePath + '/instances';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter '$sandbox' is not null or undefined
        if ($sandbox === null || $sandbox === undefined) {
            throw new Error('Required parameter $sandbox was null or undefined when calling listInstances.');
        }

        if ($sandbox !== undefined) {
            localVarQueryParameters['$sandbox'] = ObjectSerializer.serialize($sandbox, "string");
        }

        if ($filter !== undefined) {
            localVarQueryParameters['$filter'] = ObjectSerializer.serialize($filter, "string");
        }

        if ($skip !== undefined) {
            localVarQueryParameters['$skip'] = ObjectSerializer.serialize($skip, "number");
        }

        if ($top !== undefined) {
            localVarQueryParameters['$top'] = ObjectSerializer.serialize($top, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Instance>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Instance>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
