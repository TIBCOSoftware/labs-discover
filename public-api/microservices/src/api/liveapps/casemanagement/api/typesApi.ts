/**
 * Case Manager Service
 * The TIBCO Cloud(TM) Live Apps Case Manager Service manages the following resources:  * __Types__: A Type contains the essential data definition of a TIBCO(R) Live Apps application - that is, the data fields, data types and states which are created by an application designer when they create an application in Live Apps Designer. There are two sorts of Type:    * __Case__: A Case Type contains the definition of:       * the top-level data fields used by the application. These data fields (referred to hereafter as \'attributes\' of the Case) can be either simple types (such as strings or dates), or custom data types (that group together sets of existing data fields to suit the application\'s purpose).        * the states used by the application.       * details of Case Creator and Case Action processes defined in the application.               * __Structured__: A Structured Type contains the definition of a custom data type used by the application, which also has fields (\'attributes\').  * __Cases__: A Case is a particular instance of a Case Type. Users use Live Apps Case Manager to start Cases and run them through to completion. A Case contains the particular values of the data fields and states for that Case as it progresses from creation to completion.  __Paginating Results Lists__  By default, the GET /cases and GET /types methods do not return their entire results list. Instead, they return 10 items from the results list, starting from the beginning of the list. You can override this default behaviour by using the following parameters:  * $top - to specify how many items are returned from the results list. ($top must be a value from 1 to 1000.) * $skip - to specify the starting position in the results list from which to return items.  
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: liveapps@tibco.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { GetTypeResponseItem } from '../model/getTypeResponseItem';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = '/case/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum TypesApiApiKeys {
}

export class TypesApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: TypesApiApiKeys, value: string) {
        (this.authentications as any)[TypesApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Case Types are always returned. If an \'applicationId\' constraint is specified in the $filter query parameter, Structured Types are also included in the result. In other words, it is possible to get all Case Types for a Sandbox, or all Case Types *and* Structured Types for a specific application or set of applications.  By default, only 10 items from the results list are returned, starting from the beginning of the list. You can override this default behaviour by using the $top and $skip parameters. 
     * @summary Returns Types that match the specified query parameters.
     * @param $sandbox The id of the Sandbox from which to return Types. (You can obtain Sandbox Ids using the Authorization Engine Service.)
     * @param $select A comma-separated list of identifiers defining the properties to be returned for each Type. If $select is not specified, all properties are returned.    * __basic__ (or  __b__): Returns basic details - \&#39;id\&#39;, \&#39;name\&#39;, \&#39;label\&#39;, \&#39;isCase\&#39;, \&#39;applicationId\&#39;, \&#39;applicationName\&#39; and \&#39;applicationInternalName\&#39;. \&#39;isCase\&#39; is not returned for a Structured Type.      * __attributes__ (or __a__): Returns details of all attributes defined in the Type.       * __summaryAttributes__ (or __sa__): Returns details of  attributes that are included in the Case summary. (\&#39;summaryAttributes\&#39; are not defined for a Structured Type, so no data is returned.)      * __states__ (or __s__): Returns details of all states defined in a Case Type. (\&#39;states\&#39; are not defined for a Structured Type, so no data is returned.)      * __jsonSchema__ (or __js__): Returns a JSON Schema describing the format of Case data that is returned in the \&#39;untaggedCasedata\&#39; property of the response items for the GET /cases and PUT /cases methods.      * __creators__ (or __c__): Returns details of Case Creator processes that are defined in the application containing the Case Type. (\&#39;creators\&#39; are not defined for a Structured Type, so no data is returned. Case Creator processes that contain participant fields are also excluded.)      * __actions__ (or __ac__): Returns details of Case Action processes that are defined in the application containing the Case Type. (\&#39;actions\&#39; are not defined for a Structured Type, so no data is returned. Case Action processes that contain participant fields are also excluded.)      Note: The properties returned by the \&#39;creators\&#39; and \&#39;actions\&#39; identifiers (\&#39;id\&#39;, \&#39;name\&#39; and \&#39;jsonSchema\&#39;) can be subsequently used from the POST /processes method in the Business Process Management service to either:      * start a new Case (by starting an instance of a Case Creator process).      * update an existing Case (by starting an instance of a Case Action process).      For example, the following string returns basic and states properties:   &#x60;$select&#x3D;basic,s&#x60; 
     * @param $filter A filter expression that defines the Types to be returned. The expression can contain one of the following operands:  * __applicationId__ : The identifier of the specific application for which Types should be returned. (Both Case Types and Structured Types will be returned.)    Supported operator:     * \&#39;eq\&#39; - to match a specific applicationId    Supported function:    * \&#39;in\&#39; - to match a comma-separated list of applicationIds    * __applicationName__ : The name of the specific application for which Types should be returned. (Both Case Types and Structured Types will be returned.)  Apostrophes should be prefixed with a backslash to avoid them being misinterpreted as the closing single quotation mark.    Supported operator:     * \&#39;eq\&#39; - to match a specific applicationName    * __isCase__ (optional): Boolean value specifying whether to return only Case Types (TRUE). When specifying a given application or applications via applicationId/applicationName, this option is implicitly set TRUE.    Supported operators:      * \&#39;eq\&#39; - when TRUE, limits results to just Case Types  For example:    &#x60;$filter&#x3D;applicationId eq 9&#x60;    &#x60;$filter&#x3D;applicationId in(8,9,16)&#x60;    &#x60;$filter&#x3D;applicationName eq \&#39;Policy\&#39;&#x60;   &#x60;$filter&#x3D;applicationName eq \&#39;Employee\\\&#39;s Contract\&#39;&#x60;   &#x60;$filter&#x3D;applicationName eq \&#39;Purchase Order\&#39; and isCase eq TRUE&#x60;  You can use applicationId or applicationName (but not both) to limit the response to given application(s). Both Case Types and Structured Types are returned, unless \&#39;isCase eq TRUE\&#39; is included, which limits the results to just Case Types. If neither applicationId nor applicationName is specified, the response includes all applications in the Sandbox; In this scenario, only Case Types are returned.  
     * @param $skip The number of items to exclude from the results list, counting from the beginning of the list. The value must be 0 or greater. For example, &#x60;$skip&#x3D;80&#x60; results in the first 80 items in the results list being ignored. Subsequent items are returned, starting with the 81st item in the list.
     * @param $top The maximum number of items to be returned from the results list (with the first item determined by the value of the $skip parameter). The value of $top must be between 1 and 1000. For example, &#x60;$top&#x3D;20&#x60; returns 20 items from the results list, or all the results if the list contains 20 or fewer items.  If $top is not specified, a default value of 10 is used (unless $count&#x3D;true is also specified, in which case the default value of 10 is ignored). 
     * @param $count If set to \&#39;TRUE\&#39;, returns the number of Types in the result, rather than the Types themselves.    Note: $count cannot be used if $top is used. If $count&#x3D;true is specified, the default $top value (10) is ignored. 
     */
    public async getTypes ($sandbox: string, $select?: string, $filter?: string, $skip?: string, $top?: string, $count?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<GetTypeResponseItem>;  }> {
        const localVarPath = this.basePath + '/types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter '$sandbox' is not null or undefined
        if ($sandbox === null || $sandbox === undefined) {
            throw new Error('Required parameter $sandbox was null or undefined when calling getTypes.');
        }

        if ($sandbox !== undefined) {
            localVarQueryParameters['$sandbox'] = ObjectSerializer.serialize($sandbox, "string");
        }

        if ($select !== undefined) {
            localVarQueryParameters['$select'] = ObjectSerializer.serialize($select, "string");
        }

        if ($filter !== undefined) {
            localVarQueryParameters['$filter'] = ObjectSerializer.serialize($filter, "string");
        }

        if ($skip !== undefined) {
            localVarQueryParameters['$skip'] = ObjectSerializer.serialize($skip, "string");
        }

        if ($top !== undefined) {
            localVarQueryParameters['$top'] = ObjectSerializer.serialize($top, "string");
        }

        if ($count !== undefined) {
            localVarQueryParameters['$count'] = ObjectSerializer.serialize($count, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<GetTypeResponseItem>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<GetTypeResponseItem>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
